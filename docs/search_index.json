[["preface.html", "Azure DevOps for Analysis Chapter 1 Preface 1.1 Overview 1.2 Ways of Working 1.3 About this version", " Azure DevOps for Analysis Department for Education guidance 2023-11-01 Chapter 1 Preface 1.1 Overview This book acts as a resource for analysts on how Git works, and why it is useful for collaborative working and version control. This is in the context of the Department for Education Corporate environment. The documentation focuses on using Git with Azure DevOps (the Department’s existing code version control tool of choice). Within this book, we will assume the code base being used is R and R Studio. All examples will be a mix of using R Studio and the command line, however all examples should carry over neatly to other coding languages. 1.2 Ways of Working On a high level this resource is advocating a new way of working for analytical projects which can be summarised as follows: Plan your workload up front - This will help you not only better understand the project but write more efficient code to get the job done. Take one task at a time - Focus on one specific item of work at a time (substantial enough that it warrants being its own task but not so large that it’s not clear what has changed). Once it’s complete, ask for review and move onto the next one. e.g. create a script that imports and cleans all of the data sources. Collaborate - Distribute distinct items of work across analysts and bring these together to build the final product and enforce code review when there is a proposal to change the main version of the code. Do this in a systemised manner - Utilise the de facto tools for the job so that doing this is not a big overhead and can be effectively managed. 1.3 About this version This book is intended to be a living document, and will likely evolve over time. This initial version aims to give a basic overview of how to install and use Git and DevOps. More technical aspects of Git, including best practice tips, will be covered in a later version. The initial version of this work was created by analysts within DfE. We would love to hear your feedback - please provide any comments here Feedback form. Alternatively, you can contact the QA team Education.QATEAM@education.gov.uk. This version is based on previous documentation ‘VSTS for analysis’. "],["intro.html", "Chapter 2 Introduction 2.1 Background 2.2 Manual Version Control 2.3 Git 2.4 Collaboration 2.5 Azure DevOps", " Chapter 2 Introduction 2.1 Background Version control is an important part of any project. It allows you to respond reactively to requests for changes, ensure that you can easily reproduce an earlier iteration and provides an audit trail of what work has been done and the decisions that have been made. Most people would recognise this and probably are doing some form of their own version control to ensure they are able to respond, albeit not immediately, to these situations. As analytical functions move away from software such as Excel, SPSS, etc. towards fully code-based solutions using languages such as R, Python, SQL, etc. there is a wealth of pre-established expertise that can be lifted from traditional software development practices. Git is widely used software for ensuring version control is done in a standardised manner and there are a wealth of applications that allow you easily to adapt its use to your needs. 2.2 Manual Version Control Any book illustrating the usefulness of Git will start with an example similar to the following. Poor version control involves duplicating files and no standardised naming process. This approach creates versioned files using suffixes with some sort of convention. This can work if you have a small number of iterations but the following questions need to be answered: Which is the final version?! - Despite attempts to use standard naming conventions, you will inevitably reach a stage when you think you have a ‘final’ version, and then another change will come and your previous convention will be broken. What files actually constitute this analysis? - Folder structure changes over time. Scripts merge, are broken down into subscripts and files that may no longer be needed could be sitting in your folder. For a colleague quality assuring your work or anyone (including yourself) picking this up in the future, this structure is not going to help you as it will be unclear what is really needed. What are the differences between these versions? - Although these versions have different numbers we can’t easily tell what the difference between them are and would have to manually compare differences to see what’s going on. There is no indication that these are linked to specific items of work. How do you collaborate using this structure? - Collaborating using this sort of versioning means you are going to have to introduce others to this structure and/or manage the process of adding pieces of code, likely passed across via email. Keeping track of this adds to the challenge. The main take home points from this is that there are lots of challenges that come with this, and these challenges can take away from the task at hand. The bigger your project grows, the more challenging this will be. 2.3 Git Git is the widely used version control system for code development in the world today. It is command line software, language agnostic and at its root, just looks at differences between plain text files. At its most basic level Git allows the following: Commits - Create checkpoints in your code development process that you can go back to if required. Branch - Create exact replicas of your project folder in which you can try out particular ideas without editing the main version. Merge - Systematically merge these changes back into the main version of the code. A diagram to demonstrate branching with Git. Git has the ability to check the differences between 2 versions. This is invaluable information and means that rather than checking the whole project code at an undetermined time in a project the task becomes: What changed since the last working version, was that done right and does that change impact anywhere else? Note: Git is command line software but many development environments (including RStudio) provide the functionality via the graphical user interface. 2.4 Collaboration So far we have only looked at local version control. This is great for yourself to go back to previous versions of your work but doesn’t really offer a solution to collaborative coding. What is needed is a visual platform where central versions of the code can be stored with the following functionality: Users can take copies of the code on their local machine. Users can make changes to the code locally and submit those changes for review. The review process can be managed and if any changes are required they can be made in a systemised manner. You can think of these sort of systems as wrappers for Git, where merges into the main version of the code are safeguarded. One of the most well known systems for this is GitHub. GitHub is popular with open source projects because it provides good functionality for sharing code publicly. Additionally, some companies pay for business accounts. For the purposes of this book we look at using Azure DevOps. This common tool for enterprise for software development provides us a secure set-up which integrates well with our Windows (AAD) log ins. As such, this should be our collaboration tool of choice for private work. If you are undertaking work which could/should be public, you may wish to consider using GitHub. Git, GitHub and Azure DevOps (a.k.a. Git is not GitHub) A common source of confusion is the assumption that Git and GitHub are somehow the same. They are not - although the confusion is understandable given the shared naming. Git is version control software. It can either be used to manage code locally on a single machine or, much more commonly, to communicate with and manage code on a remote repository. (Other version control software exists, but is not used within DfE) GitHub is a remote repository and code collaboration tool. It can be communicated with via Git to act as a central code store for a project. Azure DevOps is a remote repository and code collaboration tool. It can be communicated with via Git to act as a central code store for a project. Put another way, Azure DevOps and GitHub do the same job. Git does a different job, and can interact with either of them. In DfE, we use the combination of Git and Azure DevOps by default, although Git and GitHub will sometimes be used where appropriate. The most important difference between Azure DevOps and Github is that the former is hosted on a private DfE server and access can be controlled; the latter is hosted on public servers and, by default, code hosted there is publically available. 2.5 Azure DevOps Azure DevOps (DevOps) is a code collaboration tool for managing projects consisting of multiple developers. DevOps is code agnostic. Although not aimed at R directly, it does provide the functionality to manage any Git-controlled project effectively. On top of this, it provides project management functionality that, when coupled with a Git workflow, encourages well planned and executed projects, where each commit is a specific item of work. This functionality is optional but is encouraged. "],["why.html", "Chapter 3 Why is it important? 3.1 Collaboration 3.2 Branching 3.3 Version Control 3.4 Audit trails and accountability 3.5 Disaster recovery 3.6 Skill Development 3.7 Knowledge-loss &amp; high turnover 3.8 Summary", " Chapter 3 Why is it important? In the dynamic landscape of civil service analysis, Git emerges as a pivotal tool with multifaceted benefits. It addresses the unique challenges faced by analysts by offering a comprehensive solution for collaborative work, version control, accountability, disaster recovery, and knowledge retention. Using Git as a tool strengthens QA practices and ensures you’re working in line with RAP principles. Here’s why Git holds particular importance for analysts in the civil service: 3.1 Collaboration Civil service analysts often work in multidisciplinary teams, collaborating on projects that can involve data analysis, policy research, and report generation. Git enables seamless collaboration by allowing multiple team members to work on the same project simultaneously from any location. It provides a structured framework for tracking changes made by each contributor, avoiding conflicts, and merging contributions into a unified final product. The ability to collaboratively work on multiple branches simultaneously saves analysts time (no waiting for colleagues to finish one part before moving on). Cloud-hosted repositories also enable other analysts to view your code (with the correct permissions), providing routes for collaborative problem-solving and help with errors or bugs when needed. Git not only saves time but also minimizes the risk of errors that can occur with manual coordination. Git’s collaborative features and features of online repository platforms enable automated checks and code quality assurance through peer reviews, ensuring the highest standards in the analytical work produced. 3.2 Branching In the civil service, the need for innovative problem-solving is constant. Git’s branching system empowers analysts with methodological agility. Each branch can be dedicated to a unique methodology, different analytical approach, or potential new feature, allowing analysts to experiment and adapt without disrupting the core workflow. This flexibility promotes a culture of continuous improvement and innovation, ensuring that the civil service stays at the forefront of data-driven decision-making. 3.3 Version Control In the civil service, accuracy and accountability are paramount. Git provides a robust version control system that allows analysts to keep a historical record of all changes made to their work. This capability is especially important when dealing with sensitive government data or policy documents. Analysts can easily revert to previous versions/past methodologies, compare changes, and identify the source of any issues, thus ensuring data integrity and transparency. Git best practices (regular commits, useful branch names and commit messages) ensure that analysts can easily track and manage changes, allowing them to focus more on analysis and less on document management. 3.4 Audit trails and accountability Government departments/agencies require a high level of accountability and transparency. Git’s commit history and branching system create an audit trail of every change made to a project. This audit trail helps analysts demonstrate the evolution of their work, which is essential when justifying decisions, responding to inquiries, or conducting internal reviews. Git’s ability to attribute changes to specific contributors adds an extra layer of accountability. The visible history of your colleagues’ work removes uncertainty and again saves time otherwise spent figuring out about changes other people have made. Git’s detailed commit messages and audit trails simplify the process of justifying decisions, responding to inquiries, and conducting internal reviews, streamlining daily tasks. This also aids quality assurance as it links closely to the key outcomes of the DfE QA framework (i.e. analysis is transparent and accountable). 3.5 Disaster recovery Data loss or file corruption can have severe consequences in the civil service, where data integrity is critical. I’m sure we’ve all had tech-disasters where we’ve lost the files/code scripts we spent the whole day working on! Git repositories can be hosted on remote servers or cloud platforms, ensuring that project data is safely stored and backed up. Committing work regularly (every 30 minutes) ensures it never gets lost, as every commit is recoverable. In DfE we use Azure DevOps for internal/sensitive repositories and GitHub for public repositories. This redundancy minimizes the risk of data loss due to hardware failures or other unforeseen events, providing peace of mind for analysts and their supervisors, knowing that their work is safeguarded against corruption or unforeseen events. 3.6 Skill Development Git is a widely used tool in the tech industry and beyond in both public and private sectors. Learning Git not only benefits analysts in their current roles but also enhances their marketability and career prospects. As the civil service increasingly incorporates technology and data-driven approaches, proficiency in Git can open doors to a broader range of opportunities within and outside the government sector. 3.7 Knowledge-loss &amp; high turnover High-turnover rates and knowledge loss are common challenges in the civil service. Git’s audit trails and detailed commit messages play a pivotal role in addressing this issue. They serve as a knowledge repository, preserving the history of decisions, methodologies, and insights. When new analysts join the team, this historical context proves invaluable in expediting their onboarding process and reducing the knowledge gap. 3.8 Summary In summary, Git is an essential tool for analysts in the civil service because it facilitates collaborative work, ensures version control, maintains accountability and audit trails, supports disaster recovery, and promotes skill development. Embracing Git as part of their toolkit empowers civil service analysts to work more efficiently, maintain data integrity, and adapt to the evolving demands of the modern public sector. "],["version-control-using-git---the-basics.html", "Chapter 4 Version Control Using Git - The Basics 4.1 Background 4.2 Installing Git 4.3 Opening Git BASH 4.4 Setting up Git 4.5 Navigating with Git BASH 4.6 Setting up a Git repository 4.7 Applying Git to a Project 4.8 Adding and committing files 4.9 Viewing the history 4.10 Making branches 4.11 Merging branches 4.12 Branching Workflow 4.13 Merge conflicts 4.14 .gitignore 4.15 Working with git in RStudio", " Chapter 4 Version Control Using Git - The Basics 4.1 Background Git is a program used to version control your files - it can be used for any files, but works best for flat text files (anything that you can open in Notepad that will show actual text - .txt, .csv, .sql, .R, .Rmd etc.) instead of binary files (anything that shows gibberish when opened in Notepad - .docx, .xlsx etc.). There are many ways to use Git, but they fall into two main categories, command line and graphical user interface (GUI). Command line interfaces of Git look like the Windows Command Prompt (or Terminal on Mac). By default the Git installation includes a command line interface called Git BASH that you can use Git from. BASH is a command line interface originally for Unix based operating systems that uses a slightly different syntax to the Windows Command Prompt. Once installed, you can also use Git from Command Prompt or Powershell, but Git BASH has a helpful colour scheme that highlights important Git features and more intuitive commands. If you would prefer to use a GUI you can choose to install one when installing Git. You can also use RStudio, Sourcetree or a whole host of other GUIs with Git. GUIs can be used by pointing and clicking, whereas the command line involves memorising some commands. Despite this, this tutorial will use the command line - Git BASH specifically. This is because the command line is the most versatile interface (it will get you out of trouble when things mess up!) and, once you learn the command line, you’ll be able to apply your skills to any GUI pretty easily. There’s some specific guidance on using RStudio to manage your git repositories further down in this chapter. 4.2 Installing Git You can download Git from here https://git-scm.com/downloads by clicking on your operating system of choice. Once downloaded, open up the installer and follow it through - the default settings should be fine. 4.3 Opening Git BASH You can open up Git BASH from File Explorer by right clicking in a folder and clicking “Git Bash Here”. This will open up a black command window with coloured text. The folder you opened Git BASH in will appear in first line of text - this is the folder that Git is “pointed” at. You run commands in Git BASH by typing them in and pressing enter. 4.4 Setting up Git When you first install Git it is advised to perform some set up steps - they aren’t necessary, but will be useful. First of all type git config --global user.name &quot;Your Name&quot; and then git config --global user.email &quot;Your Email&quot; This will add your name and email to each commit you make, which will prove useful when collaborating. You can also set the default text editor to Notepad by copying in git config --global core.editor &quot;C:Windows/system32/notepad.exe&quot; Or, if you have Notepad++ installed you could use that instead by copying in git config --global core.editor &quot;&#39;C:/Program Files (x86)/Notepad++/notepad++.exe&#39; -multiInst -notabbar -nosession -noPlugin&quot; Note, Ctrl+C and Ctrl+V don’t work for copy/pasting in Git BASH, but you can still right click to copy/paste. 4.5 Navigating with Git BASH Once in Git you can navigate through folders from the command line. Typing cd &lt;path&gt; and pressing enter will navigate to a folder path of your choice. Use doubles quotes for files paths with spaces in. You can use cd .. to move “up” one folder and ls to list everything in your current folder. When navigating with Git BASH you can press TAB to autocomplete the name of a folder or file. 4.6 Setting up a Git repository A Git repository is simply a folder that Git is tracking the changes in - it looks just like any other folder in File Explorer, but in Git BASH there will be some text after the file path. Open Git in a folder you would like to make a project in. Next type: git init This will turn this normal folder into a Git Repository - some text saying “master” will appear after the file path. This folder is now ready to start a version controlled project! 4.7 Applying Git to a Project Let’s make a toy R project that we can version control. Make an R project in the same folder as the Git repository from above. The folder will now have an .Rproj file and a .gitignore file (we’ll get to this later). Let’s create some code to plot the stopping distance of cars at different speeds - this data is pre-installed in a data set called “cars”. The code should look something like this: library(ggplot2) data &lt;- cars cars_plot &lt;- ggplot(data, aes(x = speed, y = dist)) + geom_point() cars_plot This will make a simple scatter plot (and hopefully convince you not to speed…). This seems like a good place to record our progress: save your file as “speed_dist.R” in your project folder. Now we can use Git to take a record of this save in case we need it in the future. 4.8 Adding and committing files In Git BASH type git add . This tells Git that we want to record the changes to the folder. We could type all the file names that we want to keep track of, but the dot after add adds everything. Using git add . Be really careful using git add ., particularly if you’re working with sensitive data as you could accidentally upload this to Azure DevOps. To get around this, make sure you have a .gitignore file (explained below) set up before using git add . or add files individually. Next we actually commit the change: git commit -m &quot;Added speed_dist.R&quot; Here -m means we want to add a comment and \"Added speed_dist.R\" is our comment to tell us what the commit involved - you could write anything you wanted for the comment. Let’s make a change to the code. Add ggsave(&quot;cars_plot.png&quot;, cars_plot) to the end of your code in speed_dist.R. When run, this will save your plot as cars_plot.png in your project folder. Let’s use Git to record these changes. First type git status this will show us all the files that have changed, or been created since your last commit. It should say that speed_dist.R has been modified and cars_plot.png is “untracked”. As mentioned earlier, Git deals best with flat text files, of which a .png file is not. Because of this, we won’t tell Git about the .png file, only the changes to the speed_dist.R code. This is okay though, because so long as we have the code we can always recreate the image. Use git add speed_dist.R to add just speed_dist.R (notice how last time we used git add . to add everything, but explicitly named the file here as we don’t want to add the .png file). As before we want to commit these changes: git commit -m &quot;Added save feature to speed_dist.R&quot; The workflow for making changes is as follows: Change your files Save your files Add the files you changed in Git Commit the changes in Git 4.9 Viewing the history So far we’ve made two commits. These commits start building up a history in Git. We can view a log of this history using: git log It will show the date, time, commit message, author and hash for each commit made. 4.10 Making branches There may come times when you are working to make two (or more) sets of code changes at the same time. To make sure that you don’t get confused about which change you are making Git has a feature called branches. Branches are also very useful when collaborating with others, when multiple people are making changes at once. Let’s say we want to make two changes at once to the code above: Currently the speed is in mph and the distance in feet. Let’s change it to kmph and meters. Let’s add some labels to the axes on the plot and a title. We could just make these changes one at a time as before, but if we want someone to review just one change at a time it’s easier if we use branches. So far we’ve just been working on the “master” branch, which you can think of as more of a trunk than a branch, it’s what we’d regard of as the most up to date and complete version of the code. Let’s make a new branch for our unit conversion work. “master” branch vs “main” branch We have just referred to the “master” branch. Whilst this is still the git default, conventions are moving towards use of “main” branch instead of “master” branch. This guide will refer to the “master” branch for specific examples where consistency with the git default is important and the “main” branch in other circumstances. Note the two terms refer to the same thing but they are not interchangeable. A project will have either a main or a master branch, depending on how it was set-up, but not both. You should work out which yours has and use that in place of main/master for all examples in this book. To create a new branch type in git branch unit_conversion We can type git branch again to see all the available branches. There should now be two, “master” and “unit_conversion”. To switch branches type: git checkout unit_conversion The text after the filepath in Git BASH should now say “unit_conversion”. Here we can make changes for converting units and commit them without changing the master branch. After the line data &lt;- cars copy in the following code: # convert speed to kmph data$speed &lt;- data$speed*1.609344 # convert distance to meters data$dist &lt;- data$dist*0.3048 We can now add and commit these changes as before. Use git log to see the log with these new changes. Let’s switch back to the master branch: git checkout master and look at the log git log Our unit_conversion changes aren’t there! Don’t worry this is what we want - we’ll come back to this later. For now, let’s make a new branch for the plot labels. git branch plot_labels git checkout plot_labels After the geom_point() line add + labs(x = &quot;Speed (mph)&quot;, y = &quot;Stopping Distance (m)&quot;, title = &quot;Stopping distance against speed&quot;) + theme_minimal() and add and commit these changes (remember, only add speed_dist.R!). We now have two separate branches with different changes. We could ask people to review each of these separate branches individually. 4.11 Merging branches Once someone has QA’d our code we can merge our branches into the master branch. We can do this on Azure DevOps or in Git BASH. We’ll explain how to do this in Git BASH below. Checkout the master branch. Merge the branches one at a time like this git merge unit_conversion git merge plot_labels If we look at the log all the changes from both of these branches should be visible. Note, your log might be getting long enough to run off the page. If so you can go up and down the log with the arrow keys and pressing “q” will allow to you begin typing again. You can now delete the other branches. git branch -d plot_labels git branch -d unit_conversions 4.12 Branching Workflow The branching workflow goes like this: For each large scale change make a branch Checkout the branch Change/save/add/commit as usual Checkout the master branch Merge changes from working branch into master branch Delete the working branch Start all over again for the next change 4.13 Merge conflicts Sometimes, after trying to merge two branches Git will say there are “merge conflicts”. This means that both branches changed the same line of code and Git doesn’t know which one to keep. To understand how to handle merge conflicts we’ll create one! Make a new branch called “blue_is_great” and another called “red_is_great”. Checkout out the “blue_is_great” branch and change the line with geom_point() in to geom_points(colour = &quot;blue&quot;) Save, add and commit these changes. Checkout the “red_is_great” branch and change the same line to geom_points(colour = &quot;red&quot;) Save, add and commit these changes. Let’s try to merge these into the master branch git checkout master git merge red_is_great So far so good. git merge blue_is_great You’ll get some kind of error. Something along the lines of CONFLICT... automatic merge failed... and the branch text will say master|MERGING. If we open speed_dist.R there’ll be a line saying &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD then one version of our changed line then a bunch of equals after which we’ll see the other version of our line and then &gt;&gt;&gt;&gt;&gt;&gt;&gt; blue_is_great. Thankfully, when Git finds a merge conflict it keeps both versions of the line in question so we can decide which one is right. Suppose we decide that red is better than blue for this. Let’s therefore get rid of the line that makes the colour blue and all the other extraneous lines. Now we do the usual git add and git commit. Make note of the merge conflict in the commit message, something like “Fixed merge conflict between blue and red”. For very large and complex merge conflicts it’s worth searching for &lt; HEAD to find all the instances of a conflict. 4.14 .gitignore As the number of files in our project increases it will become tiresome typing in each file we would like to track. git add file1.txt file2.txt ... file37.txt ... We could just use git add . but that would include files that we don’t want to track (like the .png we saved). The .gitignore file is a list of files that Git will ignore (hence the name), no matter how they change, allowing us to use git add . without worrying about files we don’t want to add. As mentioned earlier, a .gitignore file was created with our R Project. You can view this file in any text editor (including RStudio) and, if you do, you will see something like this: .Rproj.user .Rhistory .RData .Ruserdata These are files that RStudio creates that are of little interest in the long run - they change very frequently and aren’t necessary for someone else to run your code. Let’s add to this to tell Git to ignore the image we saved earlier. There are a few ways to do this: We could list the file exactly as it is: car_plot.png We could use a wildcard for the file name so all .png files are ignored: *.png Using the second method will be more robust in the long run because we won’t need to update it if new images are added. Add a new line to .gitignore that says “*.png” and save it. In Git BASH, typing git status will no longer show the image! In non-R projects you can create your own .gitignore file in a text editor and save it in your project folder. 4.15 Working with git in RStudio 4.15.1 Overview Within RStudio, you can choose to manage your repository using the git bash terminal as in the previous sections, use the RStudio GUI (graphical user interface) elements or use a combination of both. Below we highlight the key things you need to know to get going with a git repository within R. 4.15.2 Initial set-up RStudio needs a few small bits of set-up to be able to access git. The first step is to let it know where the git executable can be found. Using the menu bar in RStudio, go to Tools &gt; Global options... You should see the window below pop up, where you can select Git/SVN. RStudio Global options Assuming it’s not entered already, you’ll need to provide the location where the Git executable is installed. It will be called git.exe and the likely location is: C:/Program Files/Git/bin/git.exe Whilst you’ve got the Global options open, another useful option to set is the default terminal to use in RStudio. The default is the Windows Command Prompt, but Git BASH is generally easier to use. To update this, keep Global options open and select the Terminal options panel just below Git/SVN. Here you’ll see an option labeled New terminals open with:. If it isn’t already set to Git Bash, we recommend changing it to that, even if you’re primarily planning on using the RStudio git GUI. 4.15.3 Cloning an existing project The easiest way to get set up with a repository in RStudio is to use the New Project... option under File in the menu bar. When you select New Project..., you’ll then see three options: New directory, Existing directory and Version control. Assuming you’ve already got your repository set up on Dev Ops or GitHub, select Version control and then Git on the next panel that comes up. Once you’ve done that, you’ll see the options below. RStudio Clone Git Repository Here you can enter your existing Repository URL and choose a root directory for where to keep it locally. The Project directory name option will be auto-filled once you provide a Repository URL. For the root directory where the repository directory will be cloned, we recommend not using your standard One Drive folder system as this can cause issues if both One Drive and git are trying to manage file changes. Instead it’s best to navigate either to C:\\ or C:\\Users\\&lt;username&gt;\\ and create a suitable root folder (e.g. my_repos) to store your repositories in (and pinning this folder to Quick access in File Explorer can help with finding your repository directories and files quickly in Windows). Once you’ve entered your repository URL and chosen a directory in which to clone your repository, click Create Project and RStudio will do the rest. 4.15.4 Overview of the RStudio git GUIs There are three key areas within RStudio for accessing git functionality. The Git Pane, the terminal and the RStudio menu bar. 4.15.4.1 Terminal (Git BASH) The terminal offers all the Git BASH command line functionality already described. It can be accessed via the terminal pane usually found next to the R console pane. 4.15.4.2 Git pane The Git pane offers an excellent quick look at the status of your repository, whilst offering quick links for viewing or committing changes, pulling and pushing, viewing the history, accessing the project settings, and creating and switching branches. Effectively all the common things you need to do with Git. The image below shows the git pane opened for a local clone of the repo for this guidance. It consists of it’s own menu bar with buttons for each of the options listed above, alongside a preview pane showing any files that have been modified, added or removed since your last commit. The Staged column shows whether a given file has been added or staged ready for a commit and the status column shows whether a file has been added (A), modified (M) or removed (R) since the last commit. RStudio Git Panel The elements in the git pane menu bar offer the following options: Open the RStudio review changes window; Also opens the RStudio review changes window; Perform a pull; Push the current commits; Open the RStudio review changes window, defaulting to the History panel; Open the project settings window - this provides the option to undo any file saves since the last commit if you want to undo any recent changes (equivelant to running git restore); Create a new branch; Shows the current branch and allows the user to switch branches via the drop down list; Refresh the git pane preview. 4.15.4.3 Menu bar access To access the git functionality via the menu bar, navigate to Tools &gt; Version control. You should then see the options Commit..., Pull Branches, Push Branch, History and Project Setup... RStudio - Git in the menu bar 4.15.4.4 Branches, committing and pushing The bulk of any adding, committing and pushing activities using the RStudio GUI is done using the Review changes window. This can be opened either by selecting File &gt; Commit... from the RStudio menu bar, or clicking Diff, Commit or in the RStudio git pane. The Review Changes window consists of 3 panes, the top left shows a preview of all files that have been added, modified or deleted, the top right pane allows you to add a commit message and the last pane shows the git diff result for any file selected in the file preview pane. RStudio Review changes window To make a commit, review the changes in the diff pane by selecting each file in turn and click the Stage button in the Review changes menu bar (either with multiple/all files selected at once or each file selected individually). Then add your commit message and click the Commit button below the Commit message entry box. Then you can then just click the Push button above the commit message entry box to sync your changes to the remote repository. Also in the review changes window, you can restore a file to its state at the last commit made (i.e. undo any saved edits since your last commit). Simply select the file(s) you wish to restore and click the revert button. Note that this is equivalent to the command git restore and not git revert. You can switch branches by clicking on the current branch name in the Review changes menu bar, i.e. next to the History button. 4.15.5 Summary Overall, RStudio provides some useful GUI-based tools for performing the basic git version control tasks: creating and switching branches, add, commit, push and pull, restore and diff. What it won’t allow you to do are actions around merging branches or reverting to previous commits. For these, you’ll need to use either the git commands in a bash terminal or the features provided by the online platforms Dev Ops or GitHub (depending on which one you’re using with your project). "],["devops---the-basics.html", "Chapter 5 DevOps - The Basics 5.1 Background 5.2 Theory 5.3 Creating a DevOps repository for a new project 5.4 Creating a git repository for a project you’ve been doing on your computer 5.5 Adding users to a project 5.6 Pull Requests 5.7 Branch Policies", " Chapter 5 DevOps - The Basics 5.1 Background So far we have only looked at Git in the context of local projects and command line software. This alone doesn’t make collaborating on code easy. What is needed is a central platform where people can request for changes to be made to the code base and update their code based on changes by others. This concept in Git is known as remotes or remote repositories. The following are examples of interactive services that allow you to manage Git projects effectively: GitHub Bitbucket GitLab Azure DevOps. We are using Azure DevOps as this is the Department’s tool of choice for internal version control. We would use platforms such as GitHub for our more publicly facing projects (such as this book). To work with internal DevOps Repos you will need an account with Basic access level. There is a form to sort out DevOps account levels and access on the IT service portal - search for DevOps. You will also need someone to give you permission to see the DevOps project that you’re working on. For information about how to do this, please read on. If you need a new project area on DevOps, use the same IT service portal form as above. 5.2 Theory At a high level when you are using DevOps (or any type of remote) you are creating a central copy of your code on a server (the DevOps site). The aim of any project is to get your final complete code on to the main branch of the server copy. Analysts will still make and run all their changes locally but will then use the concepts of pushing, pulling and pull requesting to get the DevOps version up to date. Having this central repository and the approval processes that DevOps provides means that multiple analysts can work on a project at the same time and systematically merge all their changes into the final version after code review. The following diagram illustrates the concept of server and local copies. Visual illustrating the concept of server and local copies. Image taken from https://homes.cs.washington.edu 5.3 Creating a DevOps repository for a new project To set up a repository on DevOps you need to: Open the DevOps website. Navigate to repositories. Find the current repository name at the top of page and click on it to bring up a dropdown menu. Click “add respository” and give it a suitable name. Creating a new repository in Azure DevOps This will create you a Git repo on DevOps. By default it will give you a main branch and a README file. 5.3.1 Clone to your computer Cloning a repository means that you: Get a copy of it on your computer. Your computer stores where to find the online copy so it can talk to the online one when you ask it to. To clone the blank repository to your computer you need to get the repo’s URL. It is easiest to do this by: Going to “Files” in the “Repos” section of DevOps. Ensuring you are in the right repository by checking the name in the banner at the top of the screen. Clicking the clone button in the top right-hand corner. Copying the URL. A repository can be cloned from DevOps by clicking the ‘Clone’ button on the right hand side. Once you have copied the URL, you need to open git bash on your computer and clone the repository using the URL. When you open git bash you should do so in the folder where you want the repo to be. Ideally this will be on your C drive, outside of OneDrive or Teams, because git repositories don’t work well if OneDrive or Teams are syncing them. There is no need for the additional syncing from OneDrive or Teams because DevOps provides the online back-up that others can access. As long as you push your work regularly and at least once a day, DevOps provides the back-up and any general rules stating that work should be on OneDrive or Teams to be backed up do not apply. Once you’ve got git bash open, the clone command will look as follows: git clone git_repo_url If you are working on EDAP, it is best to clone the repo to your P drive. 5.4 Creating a git repository for a project you’ve been doing on your computer If you have already been working on a project locally you may wish to push this up and use this as the starting point for the collaborative workflow. In this case, create a new repository on DevOps but before you click the “Create” button after giving your repository a name, untick the “Add a README” box. This will give a truly blank repository. Once you click “Create” you will be take to a screen which says your new repository is empty. There will be an option to Push an existing repository from command line. In order to Push an existing repository you need to do the following: Open Git Bash in your local Git repo Copy the code from the DevOps section and run it This will set up the connection to DevOps and push an entire copy of the repo up to DevOps. 5.5 Adding users to a project DevOps is a restriced access code environment where users need to first be given permission to access the site as a whole and then individual projects. This section assumes any users added have DevOps access at the Basic account level, as described earlier in this chapter. To add users to a project: In the Overview section, go to the summary page Click on the invite button in the top, right hand corner Search for user Click Add You can add users to a project by clicking the invite button The user will then get a welcome email inviting them to the project. 5.6 Pull Requests A pull request is a particularly useful bit of DevOps functionality when you are working with multiple branches. Pull requests facilitate code reviews and QA before your work is accepted into your main/master branch. You can access pull requests from the “pull requests” page under DevOps repos section. A pull request allows a colleague to review your code before you merge it into another branch. Often the branch you are merging your work into is the main/master branch but pull requests can be used on any pair of branches. When you “complete” a pull request following a review, it uses the git merge command outlined in Chapter 2. The visual interface allows you to: Give background to the changes made and link any work items Assign a colleague, or colleagues, to conduct a code review on the changes made Discuss the changes and resolve any requests for improvements Present the differences between the two branches in a visual manner (added/removed) so that you can easily see exactly what has been changed. As a pull request ensures someone reviews your code before it is incorporated into the main/master branch it is a good tool for quality assurance. Having another person look over your code before it is accepted reduces the risk of errors being missed. Pull requests facilitate QA by other analysts. Image taken from https://www.atlassian.com/blog/bitbucket/5-pull-request-must-haves A good way of working involves ensuring all code written is reviewed via a pull request at some point. This ensures all code is checked and therefore has some QA. To facilitate this it is best to keep your main/master branch exclusively for work which has been through a pull request. Any new work should take place in a branch off your main/master branch and once complete you should always use a pull request to merge it into main/master. Pull requests are most successful when they contain a smaller number of changes because it is less likely the reviewer will miss something important. If you are writing a pull request, it is a good idea to include: Why you were doing the work you’ve done. Any context to the assumptions you’ve made whilst doing the work. A list of specific points that you would like your reviewer to check. This should always include that the code is clear enough and whether it requires further comments. An example pull request, showing the ability to add comments and provide feedback on new pieces of code. Image taken from https://www.sonarqube.org/microsoft-azure-devops-integration/ Once you are happy with the code review that’s taken place in a pull request: The person reviewing it approves the request to mark that the review is finished. The person who wrote the code and set the pull request up “completes” it which performs the merge. DevOps will delete the branch you were working in (the source branch) once you complete the pull request. This is good practice because it keeps the repo tidy. Deleting branches after you have merged the work elsewhere does not mean you lose work because all that work is on the branch you’ve merged to. 5.7 Branch Policies At this point you will have a project that anyone who is a member of has the ability to push directly to the main/master branch. Best practice ways of working include frequent code reviews via pull requests to support Quality Assurance. Pushing to main/master doesn’t allow this directly. Instead what we do is set Branch Policies which force code to be reviewed in DevOps before it can be merged into main/master. If you set any branch policies, changes to main/master have to be made using a pull request. 5.7.1 How to set branch policies To set branch policies: Go the the “Branches” page under repos in DevOps. Make sure you are looking at your intended repo by checking the centre top of the page. Hover your mouse over your main/master branch and click on the three vertical dots that appear at the right hand side of the screen. Click on “Branch policies” in the menu that appears. 5.7.2 The branch policy options At the time of writing, branch policies offer four options: Require a minimum number of reviewers - how many people need to approve the code before it can be merged. Check for linked work items - Does the pull request need to have a work item linked (this is relevant if you are using the DevOps boards feature for work planning, otherwise you can ignore this) Check for comment resolution - Do all of the comments on the pull request need to be resolved before merging is approved Limit merge types - Do you want to enforce a merge strategy (see below for more information). It is recommended that you enforce at least the first option. When you start to feel confident with Git and DevOps, you may wish to think about limiting the merge types. If you limit merge types, you will get a cleaner commit history which is easier to interrogate. The four options for merge types are: Basic merge (no fast-forward). This is the default and preserves your history exactly as it happened when you wrote your code. Squash merge. When you complete your pull request just a single commit is created on main/master containing all your work. This is a good approach for big projects where you don’t need to be able to see your intermediate steps. It is well suited to software development but may be less suitable for analytical work, especially if any of your code on intermediate steps (commits) was used to produce any form of outputs. Rebase and fast-forward. This gives your repo a linear history by reworking the commits covered by your pull request so they just cover additional work needed on top of the current state of main/master. Rebase with merge commit. This is like option 3 but it adds an additional commit which records a pull request has been completed. If you are using pull requests to support QA, this is probably a good thing because it ensures the use of a pull request is logged in your version history. "],["overall-workflow.html", "Chapter 6 Overall Workflow 6.1 Before you start - a note on data storage 6.2 Starting a DevOps project 6.3 Making Branches 6.4 Making Changes 6.5 Merging 6.6 Getting your changes back on to DevOps 6.7 Tags", " Chapter 6 Overall Workflow 6.1 Before you start - a note on data storage If possible, when working with Git and DevOps, store your data in SQL server and read just the data you need from the server. If you store data files in your repo, Git will version control all your data as well. This means that: If you delete your data they will still be in your Git history and therefore recoverable. This is problematic if you have data which you need to be able to delete. If your data files are large, your git repository becomes large. This increases the time and internet needed to interact with your work on DevOps, particularly for clone, push and pull commands. It also makes R Shiny apps slow to deploy. Even if your data files are not particularly large, if you update them frequently git remembers every version and this can add up and cause the same issues as having large files. Similarly, multiple smaller files can start to add up and cause the same problems. Prevention is better than a cure - use SQL server if you can. If you add data to Git and DevOps you should also think about who else this gives data access to: anyone with access to the DevOps project will gain access to the data in your area and DevOps project access is managed centrally. Therefore it is a bad place for personal or sensitive data because you cannot control access to it. If you use GitHub instead of DevOps everything will be public so all data included in the repo must be published. The above points apply to input data and output data from your code: You will always want to store input data somewhere sensible where the right people can access them. Try to choose SQL server. You may want to store output data on SQL server, depending on what you are using them for. If you do not want your output data on SQL server consider having a folder included in your .gitignore file (see the chapter “Version Control Using Git - The Basics”) which git does not track. If you use a git ignored folder you need to treat its files as temporary files - they may not be up to date with the code so you should always rerun them before using. Make sure everyone in your team knows this so they are equally careful. You can copy any outputs you need to keep to Teams or SharePoint for future reference. If you do this, you may want to tag the commit (see below) which produced them so you can easily access the code and rerun in future if necessary. 6.2 Starting a DevOps project Make a project in DevOps Clone the repository to a local directory. Open your desired folder in File Explorer, right click and select “Git Bash here”. git clone &lt;project_name&gt; Cloning makes a copy of your project from DevOps on your computer which allows you to work on the code. It also records the location of your DevOps repository on your computer which allows you to share (push) your changes back to DevOps once you have done some work. This is a bit like OneDrive syncing your files with the cloud apart from the fact it only happens when you specifically tell it to. We recommend that, to get the most from DevOps, you use it from the start of a project. This allows a continuous process of making small changes and having them QA’d, instead of doing a huge QA right at the end. However, you may have started a repository locally and wish to put it on DevOps. In that case you can push to DevOps. Add the DevOps repository as your “remote” git remote add origin &lt;repo_URL&gt; Push your local changes up to DevOps (make sure you’ve committed your changes first!) git push -u origin --all &lt;repo_URL&gt; 6.3 Making Branches To create a new branch in DevOps, go to repos, click on the drop-down menu next to the current branch name, and click ‘New Branch’. Creating a new branch in DevOps Once the branch has been created, you will have to git pull to pull these changes to your local repository. git pull Your local repository will now “know” about the branch you just made. Checkout the branch you made on DevOps (make sure the branch names are the same). git checkout &lt;your_branch_name&gt; 6.4 Making Changes Make your code changes Commit your changes. You can make as many commits as you need to. As ever, make them roughly self-contained chunks that would be easy for someone to review piece by piece. git add &lt;file_list&gt; git commit -m &quot;Commit message&quot; 6.5 Merging Reminder: “master” branch vs “main” branch Repositories usually have either a “main” or a “master” branch. The two terms refer to the same thing but “main” is considered more inclusive language. Our examples in this chapter will refer to a “main” branch rather than a “master” one. When you’ve made enough changes to complete your work item checkout the main branch in your local repository and git pull in case anyone else had made changes. git checkout main git pull Switch back to your working branch. Merge any changes from main. git checkout &lt;your_branch_name&gt; git merge main Sort out any merge conflicts. The command git status will list the files that have merge conflicts. Open the files with the conflicts, and search them for “&lt;&lt;&lt;&lt;”. Everything from the next line up until a line of “====” will be from the main branch. Everything from the “====” line until “&gt;&gt;&gt;&gt;” will be from your working branch. Work through the code to make sure that you keep all the necessary changes. There may be changes from main and your branch that you want to keep, so don’t just idly delete things! An example of a merge conflict in DevOps. Image taken from https://stackoverflow.com/questions/64689623 Add and commit the changes. git add &lt;file_to_be_merged&gt; git commit -m &quot;Commit message (it&#39;s advised to mention the merge)&quot; 6.6 Getting your changes back on to DevOps Push (send) your changes to DevOps git push On DevOps make a pull request for your branch Have someone review your work. If any changes are required, go back to Making Changes and work from there again. Merge your branch into main Find some more work, go back to the top and start again. 6.7 Tags Tags effectively label specific Git commits so you can easily find them again in future. In DevOps they show up in the Repos section under Tags. They are valuable if you’ve produced some outputs and wanted to label the code which produced them for future reference. If you include “/” in your tag names, they will show up in folders on DevOps. An example of using tags within a repository. Image taken from https://leonardo-matsumota.com To create a tag on your computer: Make sure the current checked out branch/commit is what you want to tag then run the following: git tag -a tag_name -m &quot;Description of what your tag is for&quot; Note that tag_name does not need quotation marks around it but the tag description should be text surrounded by quotation marks. You then need to tell DevOps about the tag. You can do this with: git push origin tag_name If you have multiple tags you can tell DevOps about them all in one go using: git push origin --tags To create a tag on DevOps: Go to the Tags page. Click the “New tag” button. Give your tag a name. Choose what you want your tag to be based on using the drop down menu. If you choose a branch it will be the most recent commit on that branch. If you need an older commit you will need to find the commit reference (SHA) and search for it. Add a description to explain why the tag was added. If you want to use your tag to access a past version of your code: On DevOps go to the “Tags” page and click on the tag you want to look at the code for. This will take you to a page showing a folder of files - these are the version of files that you applied your tag to. If you wish to access the code on your computer, it is just like checking out a branch. Open git bash and run: git checkout tag_name When you checkout a tag it sets all your local files to the version that was tagged. If you do this, you will get a warning message from git saying you are in “detached head state” which essentially means you are not on any branch. If you wish to continue working on these files you will need to put them on a branch: the warning message about “detached head state” explains this. However, for reference, you will need a git switch command to put the work on to a new branch: git switch -c new_branch_name "],["common-issues-tips.html", "Chapter 7 Common issues &amp; tips 7.1 Common issues and how to fix them 7.2 Other tips 7.3 Work Items", " Chapter 7 Common issues &amp; tips This section outlines some common issues you may run into, and how to fix them, as well as describing a few useful commands to make Git a little more user friendly. 7.1 Common issues and how to fix them 7.1.1 I’ve realised I made an error in my commit If you’ve just committed some changes but realised a mistake in them you can “amend” the commit. However, this should be done before you push your changes! Things can get complicated if you try amending public commits. To amend the commit, correct the file, add the file in Git and then use this command to combine the correction into the previous commit: git commit --amend (Technically this combines both commits into a new commit that overwrites the last one). If you’ve made a typo in your commit message you can also correct it with amend. Say your last commit looks like this: 109563e Some User | 2018/01/27 10:44 Added mew featuere Adding the -m flag to your amend allows you to add a new comment. git commit --amend -m &quot;Added new feature&quot; Your history will then look like this: 23237f1 Some User | 2018/01/27 10:44 Added new feature 7.1.2 I want to go back to an earlier commit You’ve made some changes that didn’t work out for whatever reason, and now want to return your code to an earlier state. There are two ways to do this: reset and revert. 7.1.2.1 Reset This option will “roll back” your directory to its earlier state, essentially going back in time and removing any changes since the commit you go back to. Use git reset --hard &lt;commit-hash&gt; where &lt;commit-hash&gt; is the unique hash of the commit you want to go back to (you can find this via git log). The --hard option in this command means that your working directory and staging area will also be reset, which is usually what you want, but be careful as you will lose any uncommitted changes when you use this command. 7.1.2.2 Revert This option keeps all the changes you have made, but adds an extra commit with new changes that reverse the previous changes. You will usually want to use git revert HEAD to revert the most recent commit (which is what the HEAD in this command refers to). Reverting anything other than the most recent commit is not recommended. If you want to revert multiple commits at once, you can use something of the form git revert --no-commit HEAD~2^..HEAD followed by git commit -m &quot;Reverted last three commits&quot; Walking through this: The --no-commit part of the command means that the reversion will change the working directory and staged files, but not yet be committed. (You’ll have seen that we commit it afterwards, which is the usual way to work when reverting multiple commits at once). HEAD~2^ means the commit two commits before HEAD (and e.g. HEAD~4^ would be the commit four commits before HEAD) .. indicates to include all commits between the two specified So the first command reverts the most recent commit and the two before it - three commits in all - but only makes those changes in the working directory and staging area rather than committing them. Then the second command is a standard commit command which commits them all with a message. 7.1.2.3 When should I use reset vs revert? The two commands will result in a different git history. With reset, any changes you roll back will not appear, giving a shorter history; with revert, everything that happened will be recorded and the history will be longer. So if it’s not necessary for anyone to know about the rolled back changes, reset is probably better; if you need a record of what happened then revert is probably better. There are a few other important considerations too: You need to be a bit more careful when using reset, as it will erase any uncommitted changes and you’ll be unable to recover them. If any of the changes you want to reverse have been pushed to a remote server, you should use revert so that it’s clear to others that changes have been rolled back. Using reset on a shared history will create confusion because it will not be clear what has happened. You can’t (easily) revert past a merge because it’s unclear which merged branch you want to revert to. reset is easier to use when the history you want to roll back includes a merge. 7.1.3 I’ve worked on the wrong branch (but haven’t committed yet) You’ve made some changes to your code, saved them, but realised that you’ve been working on the wrong branch before committing. Fortunately, this is pretty easy to solve. The git stash command is your friend here: it allows you to store all your file changes away since the last commit away, and bring them back where you want - usually on a new branch. The commands are: store away any changes with git stash (If you check git status at this point you’ll see that your file changes since your last commit no longer appear.) Then switch branch with git checkout &lt;your_branch&gt; and use git stash pop to bring your changes back. That’s it! Using the pop command does not commit your changes - you have simply moved uncommitted changes from one branch to another - and once you have “popped” your changes they will be removed from the stash. Occasionally popping changes from the stash will cause a merge conflict. You can resolve this in the same way as a usual merge conflict by editing the files, and then add the result to your next commit. (Note that when a pop causes a merge conflict, your changes will not be removed from the stash like normal so you will still have access to them if needed.) Using the stash The git stash can technically hold many different sets of changes at once, but it is not good practice to store anything in the stash long-term. It is a temporary store and should only be used to quickly move changes around when needed. 7.1.4 I’ve worked on the wrong branch (and committed it) If you’ve only realised that you’re working on the wrong branch after committing your code, then you’ll need to do two things. The first is to get the code onto the correct branch, and the second is to remove it from the wrong branch you committed it to. If you forgot to create a new branch, you can create one now that includes the commits you want using git branch &lt;new_branch_name&gt; then roll back the current branch as described here. If you already created a branch but forgot to switch to it, you’ll need to move the commits to the correct branch. You can do this by checking out the correct branch and copying the commits to it using cherry-pick: git checkout &lt;correct_branch&gt; git cherry-pick &lt;commit-hash&gt; where &lt;commit-hash&gt; is the commit you want to copy over. For multiple commits, you can copy them all over using git cherry-pick &lt;commit-hash-1&gt;..&lt;commit-hash-n&gt; where &lt;commit-hash-1&gt; is the earliest commit you want to copy and &lt;commit-hash-n&gt; is the most recent. Then check out the branch you accidentally committed them to and roll it back as described here. 7.2 Other tips 7.2.1 Log Customisation and Aliases You can customise the log by adding extra arguments. For example, adding the --oneline argument the log is cut down to one line per commit. git log --oneline There are a lot of possible arguments to add to the log. This example will show the latest commit on each branch, give a rough branching diagram and put the date in a specified format. git log --pretty=format:&#39;%C(yellow)%h%Creset %an| %Cgreen%cd%Creset %s %C(cyan)%d&#39; --graph --all --date=format:&#39;%Y/%m/%d %H:%M&#39; All the possible arguments to add to git log are in the documentation here. Eventually you’ll have too many arguments to sensibly type, so you can use an alias. An alias allows you to define a new command based on an old command. You define one like this: git config --global alias.&lt;your_alias_name&gt; = &lt;your_command&gt; After this you can type git &lt;your_alias_name&gt; to carry out the command. For example, using the long, customised log from above we can define a new command, “hist”. git config --global alias.hist = log --pretty=format:&#39;%C(yellow)%h%Creset %an| %Cgreen%cd%Creset %s %C(cyan)%d&#39; --graph --all --date=format:&#39;%Y/%m/%d %H:%M&#39; Allowing us to type: git hist to view a fancy version of the log, without having to type out a huge command! 7.3 Work Items DevOps has rich project management functionality that can be used to manage projects of all sizes. At it’s most complex you can utilise a mix of Epics, Stories, Features, Tasks, Issues and User stories to manage your project. These terms and planning stages for a project come from software development. Instead we recommend treating features as the main type of work item and breaking your workload down into a number of features. This is similar to what you would do on GitHub with Issues. With features you can again add lots of metadata but the most useful will be the following: Name Description Assigned to There are then numerous ways to visualise work allocations across Azure DevOps ranging from individual task assignments to project boards (similar to trello boards). By utilising work items you take out the need for tracking tasks manually. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
